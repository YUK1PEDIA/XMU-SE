1. **FS3399M4实验箱中的MPU(RK3399)和MCU(STM32)各自基于ARM家族中的哪个核心（cortex-A系列，cortex-M系列，cortex-R系列）？**

   - MPU(RK3399) 基于 Cortex-A72 核心板，属于 ARM 家族中的 Cortex-A 系列。

     ![image.png](https://s2.loli.net/2024/12/29/bTquyYGrzLal4fJ.png)

     ![image.png](https://s2.loli.net/2024/12/29/4gt21fKnVqZDj9F.png)

   - MCU(STM32) 基于 Cortex-M4 核心板，属于 ARM 家族中的 Cortex-M 系列。

     ![image.png](https://s2.loli.net/2024/12/29/sZ83GLfnOWljzxC.png)

2. **实验环境的搭建，了解各个开发平台，软件的名称，如VMware，Ubuntu，putty，xshell，其作用是什么？**

   | **工具名称** | **作用**                                                     | **常用场景**                                                 |
   | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | VMware       | 虚拟机平台，用于搭建开发环境，隔离操作系统                   | 在 Windows 中安装 Ubuntu，测试嵌入式开发环境                 |
   | Ubuntu       | Linux 系统，提供嵌入式开发工具链和环境                       | 提供编译、交叉编译工具，作为开发板的调试和运行支持环境       |
   | PuTTY        | 轻量化终端仿真工具，支持 SSH、串口调试                       | 通过串口调试嵌入式设备，使用 SSH 远程登录开发板              |
   | Xshell       | 高级终端仿真工具，功能类似 PuTTY，提供更强的会话管理和界面友好性 | 同时连接多个嵌入式设备，支持文件传输，方便嵌入式设备与主机之间交互 |

3. **镜像烧写的概念？开发板中的存储设备是什么？**

   - 镜像烧写是指将一个**预先生成的系统镜像文件**（通常是操作系统或固件）通过专用工具写入到目标设备（如开发板）的**存储设备**中的过程。镜像文件是目标设备操作系统和必要软件的完整拷贝，包含所有启动文件、文件系统和配置。
   - 开发板中的存储设备是用来**保存操作系统、程序、数据等内容的硬件**。通俗地讲，它就像是电脑的硬盘，提供一个地方来存储和读取数据。

   | **开发板**     | **存储设备类型**      | **特点和用途**                                               |
   | -------------- | --------------------- | ------------------------------------------------------------ |
   | **MCU 开发板** | 内部 Flash            | 固件存储，容量小（几 KB 到几 MB）。                          |
   |                | 内部 SRAM             | 运行时临时数据存储，容量小（几十 KB 到几百 KB）。            |
   |                | SPI Flash（外部可选） | 通过 SPI 接口扩展，存储非易失性数据，容量较小（1MB - 16MB）。 |
   |                | SD 卡（外部可选）     | 数据存储，适合存储大量数据（如日志文件），容量灵活（几 GB - 数百 GB）。 |
   | **MPU 开发板** | eMMC                  | 主存储设备，用于存储操作系统和数据，容量较大（4GB - 128GB）。 |
   |                | SD 卡                 | 外部存储设备，用于启动或存储操作系统镜像，容量灵活。         |
   |                | SPI Flash             | 存储引导程序（如 Bootloader），容量小但速度快。              |
   |                | DRAM（DDR3/DDR4）     | 系统运行时内存，容量较大（1GB - 4GB），支持高性能任务。      |

4. **“ARM裸机”的含义，实验中如何进行操作控制的？**

   - ARM裸机指的是在基于ARM架构的处理器或微控制器上直接开发和运行程序，而**不依赖操作系统**（如 Linux、Windows）。在这种开发模式下，程序直接运行在硬件上，由开发者手动管理硬件资源（如 CPU、内存、外设等）。裸机编程的特点是**没有操作系统的参与**，因此程序需要自行负责硬件初始化、任务调度、资源管理等功能。

     ![image.png](https://s2.loli.net/2024/12/29/3kofmLUTGnQ6I4N.png)

   - 实验中如何进行操作控制的？

     - 准备 JTAG 仿真线 + USB 线、串口线、USB 扩展器和电源线，进行接线
     - 设置试验箱开关，MPU：ON，MCU：OFF，电源开关：ON
     - 设置拨码开关位置：BOOT0：左边、BOOT1：左边，MPU：右边，Debug：右边
     - 检查串口驱动
     - 烧写试验箱的 Ubuntu 镜像
     - 安装有关软件（虚拟机），并运行虚拟机
     - 运行试验工程

5. **嵌入式系统的交叉开发环境指的是什么？（教材P16-1.4.4）**

   - 交叉开发环境是指**编译、链接和调试嵌入式应用程序的软件开发环境**。嵌入式系统的程序开发通常在 **宿主机（Host）** 上进行，而最终的应用程序会运行在 **目标机（Target）** 上。
     - **宿主机（Host）**：通常是功能强大的计算机系统（如 Windows 或 Linux 系统）。
     - **目标机（Target）**：通常是嵌入式系统设备，运行环境资源有限。
   - 简单来说，交叉开发环境是嵌入式系统开发的关键工具链，它通过宿主机与目标机的配合完成嵌入式应用的开发和调试工作。宿主机负责代码的编写、编译、调试，而目标机负责运行实际的应用程序，从而有效解决嵌入式设备资源受限的问题。

6. **宿主机和目标机之间通信的四种方式。（教材P86）**

   - **串口通信**
     - 通过串口（如 UART）进行通信。
     - 常用于调试目标机的信息，例如输出调试信息或与目标机进行命令交互。
     - 串口通信成本低、配置简单，是嵌入式开发中常见的通信方式。
   - **以太网接口**
     - 利用网络连接宿主机和目标机，通过以太网进行数据传输。
     - 适用于需要高效传输大数据量的场景，例如传输文件或进行远程调试。
     - 以太网通信的优势是速度快、可靠性高，但需要硬件支持和配置。
   - **USB 接口**
     - USB（Universal Serial Bus）接口是一种标准的高速通信接口。
     - 它支持热插拔，系统可以自动搜索和安装设备，无需用户手动配置。
     - 常用于目标机与宿主机的数据交互和调试操作。
   - **JTAG 接口**
     - JTAG（Joint Test Action Group）是一种硬件调试协议接口。
     - 它常用于嵌入式系统的调试，支持下载程序到目标板上或进行低级硬件调试。
     - JTAG 提供强大的调试能力，例如读取寄存器状态、设置断点等。

7. **GCC的编译过程以及对应的具体命令。（教材P90-91）**

   - GCC 的编译过程一般分为 **预处理**、**编译**、**汇编** 和 **链接** 四个主要阶段。

     - **预处理**

       - **作用：**

         - 处理 `#include`、`#define` 等预处理指令，展开宏和头文件。
         - 生成扩展后的源文件（通常以 `.i` 作为后缀）。

       - **命令：**

         ```bash
         gcc -E hello.c -o hello.i
         ```

         - `-E`：只进行预处理，不做其他处理。

     - **编译**

       - **作用：**

         - 将预处理后的代码（`.i` 文件）转换为汇编代码（`.s` 文件）。
         - 负责语法检查和生成对应处理器架构的汇编代码。

       - **命令：**

         ```bash
         gcc -S hello.i -o hello.s
         ```

         - `-S`：只进行编译，不进行后续处理，生成汇编代码文件。

     - **汇编**

       - **作用：**

         - 将汇编代码（`.s` 文件）转换为目标代码（`.o` 文件）。
         - 目标文件是机器代码，但尚未链接成可执行程序。

       - **命令：**

         ```bash
         gcc -c hello.s -o hello.o
         ```

         - `-c`：只进行汇编，生成目标文件。

     - **链接**

       - **作用：**

         - 将目标文件（`.o` 文件）与库文件链接，生成最终的可执行文件。

       - **命令：**

         ```bash
         gcc hello.o -o hello
         ```

         - `-o`：指定输出文件名（这里为 `hello`）。

8. **ARM状态和THUMB状态是如何切换的？（教材P22-2.2.2ARM状态和Thumb状态）**

   - **首先ARM处理器支持两种指令集模式**：
     - **ARM状态**：使用32位ARM指令。
     - **Thumb状态**：使用16位Thumb指令，指令更紧凑，占用内存更少。
   - **状态切换的实现方式**：
     - ARM状态与Thumb状态的切换通过修改**CPSR寄存器的T位**实现。
       - **CPSR[T]=0**：处理器处于ARM状态。
       - **CPSR[T]=1**：处理器处于Thumb状态。
   - **切换指令**：
     - **BX指令（Branch and Exchange）**：
       - 用于状态切换，具体通过目标寄存器的最低位(Rn[0])的值决定切换的状态：
         - **Rn[0]=0**：跳转到目标地址并切换到ARM状态。
         - **Rn[0]=1**：跳转到目标地址并切换到Thumb状态。
     - **BLX指令（Branch with Link and Exchange）**：
       - ARMv5引入的新指令，结合了BL和BX的功能。
       - 可在跳转的同时完成状态切换和返回地址的保存。
   - **状态切换的流程**：
     - **函数调用中切换**：
       - ARM状态下调用Thumb状态函数，使用BX指令完成状态切换。
       - Thumb状态下调用ARM状态函数，同样使用BX或BLX指令切换状态并跳转。
     - **返回过程**：
       - 返回时需要使用LR（链接寄存器）保存的返回地址，并再次使用BX指令完成状态切换。

9. **RT-Linux。（教材P56-3.1.2 &P60-3.3.2 ）**

   - **什么是 RT-Linux**
     - **RT-Linux** 是 Real-Time Linux 的缩写，是一种具有硬实时特性的多任务操作系统。
     - 它基于传统 Linux 内核，通过在其基础上添加一个实时内核实现硬实时性能。
     - 主要特点：
       - 支持硬实时特性，保证任务在规定的时间内执行。
       - 兼容标准的 Linux 系统，提供多任务和多线程能力。
       - 支持部分 POSIX.1b 标准。
   - **RT-Linux 核心原理**
     - **实时内核引入**：
       - 通过在标准 Linux 内核外部增加一个实时内核，实时内核处理硬中断和高优先级任务，而标准 Linux 内核被降级为低优先级任务。
       - 标准 Linux 内核作为实时内核的“普通任务”运行，其优先级最低。
     - **中断处理机制**：
       - 硬件中断首先由实时内核处理，只有非实时任务相关的中断才会传递给标准 Linux 内核。
       - 硬实时内核实现中断屏蔽，并对高优先级任务进行调度。
   - **RT-Linux 的调度机制**
     - **任务优先级**：
       - 高优先级任务由实时内核调度，实时任务的执行不会被低优先级任务打断。
       - 标准 Linux 内核中的任务只能在实时任务空闲时执行。
     - **调度策略**：
       - 默认情况下，RT-Linux 不采用优先级的调度策略，而是支持用户根据需求自定义调度算法。
       - 常见调度算法包括：
         - **优先级调度**：高优先级任务优先执行。
         - **周期性任务调度（RM）**：为周期性任务分配固定的优先级。
         - **最优延迟调度（EDP）**：确保任务执行延迟最优。
   - **RT-Linux 的两种中断**
     - **硬中断**：
       - 由实时内核直接处理，响应时间通常在 15 微秒以内，保证硬实时任务的快速响应。
       - 硬中断处理完成后，实时内核调度任务运行。
     - **软中断**：
       - 将非实时任务相关的中断传递给标准 Linux 内核处理。
       - 软中断通常具有较大的延迟，但不会影响实时任务的执行。
   - **RT-Linux 的数据通信机制**
     - **RT-FIFO**：
       - RT-Linux 引入了 RT-FIFO（先进先出队列）作为实时任务与标准 Linux 任务之间的数据通信机制。
       - RT-FIFO 被映射为字符设备文件，例如 `/dev/rtf0`、`/dev/rtf1` 等。
       - 用户可以通过 FIFO 实现数据交换，最大支持 150 个 FIFO 队列。
   - **RT-Linux 的系统架构**
     - **实时内核**：
       - 提供硬实时功能，负责调度高优先级任务和硬中断处理。
     - **标准 Linux 内核**：
       - 作为实时内核的一个普通任务运行，处理低优先级任务。
     - **RT-FIFO**：
       - 数据通信通道，实现实时任务与标准任务之间的信息交互。
   - **RT-Linux 的优势**
     - **硬实时性能**：
       - 能够满足对时间敏感的任务需求，确保实时任务在规定时间内执行。
     - **兼容性强**：
       - 支持标准 Linux 系统的所有特性，同时提供实时扩展。
     - **灵活的调度算法**：
       - 用户可以根据应用需求选择或自定义调度算法。
     - **广泛应用场景**：
       - 被应用于航空航天、工业自动化、科学仪器、图像处理等对时间敏感的领域。
   - **RT-Linux 的局限性**
     - **开发复杂度高**：
       - 实现和维护需要深入理解实时内核和 Linux 系统。
     - **对硬件要求高**：
       - 实时任务的执行依赖于硬件的中断和性能支持。
     - **调试难度大**：
       - 实时任务与标准任务共存，增加了调试的复杂性。

10. **嵌入式文件系统分类。（教材P66，典型代表JFFS2，YAFFS2，Ramfs）**

    - **JFFS2（Journaling Flash File System 2）**
      - **特点**：
        - 针对 NAND Flash 和 NOR Flash 设计的日志型文件系统。
        - 提供写入均衡功能，延长 Flash 的寿命。
        - 支持断电保护，防止意外断电导致的数据损坏。
      - **应用场景**：
        - 嵌入式设备中使用 Flash 存储设备作为主要存储介质。
        - 常用于需要高可靠性和断电保护的嵌入式系统。
    - **YAFFS2（Yet Another Flash File System 2）**
      - **特点**：
        - 专为 NAND Flash 优化的文件系统。
        - 支持大页 NAND Flash，具有更高的性能。
        - 提供直接挂载文件系统的功能，并带有自带的 NAND 驱动支持。
      - **应用场景**：
        - 需要高性能和大容量 NAND Flash 存储的嵌入式系统。
        - 对性能和存储效率要求较高的场景，如智能设备和工业控制。
    - **Ramfs（RAM File System）**
      - **特点**：
        - 基于 RAM 的文件系统，文件直接存储在内存中。
        - 高速读写性能，不支持数据持久化。
        - 适用于临时数据存储，数据断电即丢失。
      - **应用场景**：
        - 系统临时文件存储，如 `/tmp` 或 `/var` 目录。
        - 提高系统性能的场景，如加载速度要求较高的嵌入式设备。

11. **Bootloader的两阶段主要完成的工作。（参看教材P109）**

    - **Bootloader 阶段 1**：
      1. 基本的硬件初始化
      2. 为加载阶段 2 准备 RAM 空间
      3. 复制阶段 2 到 RAM 中
      4. 设置堆栈指针
      5. 跳转到阶段 2 入口
    - **Bootloader 阶段 2**：
      1. 初始化阶段要使用到的硬件设备
      2. 检测系统的内存映射
      3. 加载内核映像和根文件系统映像
      4. 设置内核启动参数
      5. 调用内核

12. **字符设备，块设备与网络设备的定义。**

    - **字符设备**：
      - **定义**：以字符流的形式与用户空间交互，数据按字节顺序传输，不支持随机访问。
      - **特点**：
        - 数据一次性读写一个字符或一段字符。
        - 不需要缓存，通常为直接设备访问。
      - **示例**：串口、键盘、鼠标、打印机等。
    - **块设备**：
      - **定义**：以固定大小的数据块为单位进行数据传输，支持随机访问。
      - **特点**：
        - 数据通过缓冲区传输，读写速度较快。
        - 支持文件系统操作。
      - **示例**：硬盘、SD卡、U盘、eMMC等。
    - **网络设备**：
      - **定义**：提供网络接口，用于网络通信的数据传输。
      - **特点**：
        - 数据传输以网络协议栈为基础。
        - 通过 socket 等接口与用户空间交互。
      - **示例**：网卡、Wi-Fi模块、以太网接口等。

    | **设备类型** | **数据传输方式**     | **是否支持随机访问** | **应用场景**                  |
    | ------------ | -------------------- | -------------------- | ----------------------------- |
    | 字符设备     | 按字符流传输         | 不支持               | 串口、键盘、鼠标、打印机等    |
    | 块设备       | 按固定大小数据块传输 | 支持                 | 硬盘、U盘、SD卡等存储设备     |
    | 网络设备     | 按网络协议传输       | 不适用               | 网络通信设备（如网卡、Wi-Fi） |

13. **呼吸灯实验中的pwm英文解释，MDK的英文全称，JTAG，I2C，CAN**

    - **呼吸灯实验中的pwm英文解释**：pwm 全称为 `Pulse Width Modulation` ，通过调节信号占空比控制输出效果。

      - 占空比：是指一个周期内信号 **高电平持续时间** 占整个周期的比例，通常用百分比表示。占空比用于调节 LED 亮度，占空比越高，输出信号平均电压越高，LED 越亮。

        ![image.png](https://s2.loli.net/2024/12/29/IirgPE9C61BDjG4.png)

    - **MDK 的英文全称**：`Microcontroller Development Kit`

      ![image.png](https://s2.loli.net/2024/12/29/VpX9hziUTDgY1Wn.png)

    - **JTAG、I2C、CAN**

      - **JTAG（Joint Test Action Group）：联合测试工作组**
        - **定义**：一种标准的硬件调试接口协议，广泛用于嵌入式系统调试。
        - **功能**：
          - 硬件调试和诊断（如下载程序、设置断点、单步运行）。
          - 对处理器和芯片内部进行测试。
        - **应用**：嵌入式开发中的芯片烧写、硬件调试和电路板测试。
      - **I2C（Inter-Integrated Circuit）：集成电路总线**
        - **定义**：一种用于芯片间通信的串行总线协议，具有简单的双线设计（SDA 数据线和 SCL 时钟线）。
        - **特点**：
          - 支持主从模式，主设备控制通信。
          - 支持多主多从通信，简单易实现。
        - **应用**：常用于嵌入式系统中传感器、EEPROM、显示屏等器件的通信。
      - **CAN（Controller Area Network）：控制器局域网总线**
        - **定义**：一种高可靠性的串行通信协议，最初用于汽车电子通信。
        - **特点**：
          - 多节点通信，高抗干扰能力。
          - 数据传输具有优先级和实时性。
        - **应用**：广泛用于汽车电子、工业自动化、医疗设备等场景。

14. **STM32实验是如何接线的（除了电源线），其作用是什么？STM32所开展的实验项目中，哪些需要使用串口线？STM32实验程序的工程文件中的主要文件夹，分别存放什么文件？**

    - **如何接线？**

      ![image.png](https://s2.loli.net/2024/12/29/f6vWzM2rkYgOwHZ.png)

      ![image.png](https://s2.loli.net/2024/12/29/2B35qASXQ6pjNwD.png)

      ![image.png](https://s2.loli.net/2024/12/29/IrWhjpF8RUmquDO.png)

      ![image.png](https://s2.loli.net/2024/12/29/sFCVyGOA97Q24XR.png)

      ![image.png](https://s2.loli.net/2024/12/29/j62LURakd3xuHM1.png)

      ![image.png](https://s2.loli.net/2024/12/29/x1XTUruEyVM5f6t.png)

    - **接线的作用是什么？**

      1. **ST-Link 仿真器 + USB延长线**
         - 用于程序的烧写和调试，通过 ST-Link 工具将编译好的程序下载到 STM32 开发板。
         - 支持断点调试、寄存器查看和调试信息输出。
      2. **串口线**
         - 用于串口通信，实现与电脑或其他设备之间的数据交互。
         - 通过串口调试工具（如串口助手）显示调试信息或接受上位机命令。
      3. **拨码开关设置**
         - **开关位置**：
           - **BOOT0/BOOT1**：配置为左侧，设置 STM32 启动模式（通常为用户 Flash 启动）。
           - **Debug 开关**：切换到调试模式。
           - **MCU 开关**：打开 MCU 功能。
         - 设置 STM32 的启动模式（烧录、调试或正常运行）。
         - 开启 MCU 和调试功能，确保正常运行。

    - **STM32 所开展的实验项目中，哪些需要使用串口线？**

      - **必需使用串口线**：`6_USART1`、`13_IR_Receive`、`18_STM32F407IGH6_FreeRTOS_LCD_MoreTest`
      - **可能使用串口线**：`10_Systick_Led`、`12_ADC`、`14_Temp`、`15_lightelectric`

    - **STM32 实验程序的工程文件中的主要文件夹，分别存放什么文件？**

      ![image.png](https://s2.loli.net/2024/12/29/GR5JdHaNTDsfwCA.png)

15. **ARM裸机实验和Qt实验，会涉及到同样的接线，其用途有何不同？**

    - **ARM裸机实验**
      - **JTAG仿真器 + USB 线**
        - 用于烧写 ARM 裸机代码。
        - 调试裸机代码运行过程，查看寄存器值和内存状态。
      - **串口线**
        - 主要用于裸机代码的调试，输出程序的运行结果。
        - 裸机环境下无操作系统支持，串口是核心的 I/O 输出手段。
      - **USB 延长线**
        - 用于连接多种外设，辅助调试裸机程序。
        - 例如连接额外的调试工具或供电设备。
      - **拨码开关配置**
        - 配置启动模式（如从NAND或SD卡启动），确保裸机程序能够从正确的存储设备中加载。
    - **Qt实验**
      - **Type-C USB 线**
        - 用于将Qt应用程序从主机传输到开发板中运行，主要针对高层应用程序。
        - 提供调试Qt应用运行状态的接口。
      - 串口线
        - 串口用于调试Qt应用程序的输出日志或控制界面操作。
        - 在Qt实验中，串口交互更多地用于监控应用层的行为，而非底层硬件的调试。
      - **USB延长线**
        - 辅助将多种设备（如调试接口、传感器模块）连接到开发板。
        - 更强调应用程序与外设之间的数据交互。
      - 拨码开关配置
        - 配置启动模式，确保开发板能够支持Qt环境和系统运行（如从eMMC或TF卡启动）。
    - **总结**
      - **ARM裸机实验**：更关注硬件底层调试，如寄存器配置、串口日志、裸机程序的执行过程。
      - **Qt实验**：重点在高层应用程序开发和调试，如Qt界面设计、与外设（如RFID卡）交互的验证。
        相同接线在两类实验中支持的开发环境不同，因此用途和关注点也不同。

16. **ARM裸机实验中LED实验的文件夹中那几个文件都是做什么用的？**

    ![image.png](https://s2.loli.net/2024/12/29/BSDK8skfFEiezQJ.png)

    - `fs_assembly_led.s`：
      - 功能：汇编语言程序，包含控制LED灯的核心代码。
      - 作用：实现裸机实验中的LED灯控制逻辑，直接与硬件寄存器交互。
    - `Makefile`：
      - 功能：编译脚本文件。
      - 作用：自动化完成代码编译、链接等流程，将源码生成可执行文件。
    - `map.les`：
      - 功能：链接脚本文件。
      - 作用：定义程序的内存布局，比如代码段、数据段、堆栈等在内存中的具体位置。
    - `fs3399.init`：
      - 功能：远程调试初始化文件
      - 作用：设置实验板的基本硬件配置，初始化必要的硬件资源（如时钟、GPIO等）
    - `core`：
      - 功能：系统内核文件
      - 作用：存放与系统核心功能相关的代码或库文件，为实验提供底层支持。

17. **设备驱动程序设计中涉及的内存映射都有哪些？函数原型是什么？（教材P206-9.5 以及相应的PPT）**

    - **物理地址映射到虚拟地址**

      - **用途**：将I/O设备的物理地址映射到内核的虚拟地址空间，方便访问这些I/O设备的寄存器。

      - **函数原型**：

        ```c
        void* ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags);
        void iounmap(void* addr);
        ```

      - 参数说明：

        - `phys_addr`：要映射的起始物理地址。
        - `size`：映射空间的大小。
        - `flags`：映射的属性标志。

    - **内核空间映射到用户空间**

      - **用途**：将内核地址映射到用户空间，允许用户应用程序直接访问设备的内存。

      - **函数原型**：

        ```c
        void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);
        int (*mmap)(struct file* filp, struct vm_area_struct* vma);
        ```

      - 查看命令：

        ```bash
        cat /proc/<directory>/maps
        ```

    - **建立页表方法 1：`remap_pfn_range`**

      - **用途**：将物理地址映射到虚拟地址时创建页表。

      - **函数原型**：

        ```c
        int remap_pfn_range(struct vm_area_struct* vma, unsigned long virt_addr,
                            unsigned long pfn, unsigned long size, pgprot_t prot);
        ```

    - **建立页表方法 2：`nopage`**

      - **用途**：使用VMA的`nopage`方法实现灵活的内存映射。

      - **函数原型**：

        ```c
        struct page* (*nopage)(struct vm_area_struct* vma, unsigned long address, int* type);
        ```

18. **Qt实验程序的流程图框架分成哪三层？（参QT实验课件），并能够将某个实验工程文件夹中的文件对应到各个层中。**

    ![image.png](https://s2.loli.net/2024/12/29/zRS1A3fae6pLGXK.png)

19. **ARM裸机实验中的LED（纯汇编）代码，ARM裸机蜂鸣器实验代码，ARM裸机查询方式按键实验代码，基于寄存器控制的LED灯的Linux设备驱动程序代码，按键控制步进电机转动的代码，QT实验中的主窗口代码 。（上述代码均为核心代码，如.c, .cpp等）**

    - **ARM裸机实验中的LED（纯汇编）代码**

      ![image.png](https://s2.loli.net/2024/12/29/wgMG327KyZNoDlO.png)

      ![image.png](https://s2.loli.net/2024/12/29/MOXm8NFU6L7CaIx.png)

    - **ARM裸机蜂鸣器实验代码**

      ![image.png](https://s2.loli.net/2024/12/29/MzIH8SfX3oF19Og.png)

    - **ARM裸机查询方式按键实验代码**

      ![image.png](https://s2.loli.net/2024/12/29/kr2Lczne3AuTifK.png)

      ![image.png](https://s2.loli.net/2024/12/29/qnHNhJgKdFbERXP.png)

    - **基于寄存器控制的LED灯的Linux设备驱动程序代码**

      ![image.png](https://s2.loli.net/2024/12/29/51a7QMeUGktdqgz.png)

      ![image.png](https://s2.loli.net/2024/12/29/rvgs8StHfA53Nqc.png)

      ![image.png](https://s2.loli.net/2024/12/29/H5dkAwSJX3nyV9j.png)

      ![image.png](https://s2.loli.net/2024/12/29/6avUDw3ZrVRj2Af.png)

      ![image.png](https://s2.loli.net/2024/12/29/PqOMAaSLxGr8vB3.png)

    - **按键控制步进电机转动的代码**

      ![image.png](https://s2.loli.net/2024/12/29/DnHx7J41ewsPIlY.png)

      ![image.png](https://s2.loli.net/2024/12/29/SdLDaP7k8euh3Gy.png)

      ![image.png](https://s2.loli.net/2024/12/29/pQ4AHe2YKDjvmd3.png)

    - **QT实验中的主窗口代码**

      ![image.png](https://s2.loli.net/2024/12/29/1QDqrnNsBKTeWIZ.png)

      
